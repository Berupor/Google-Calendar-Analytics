{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Analytics Docs","text":"<p>Welcome to the documentation for the Calendar Analyzer project. This project provides a module that allows you to analyze events from a Google Calendar and generate charts to visualize the data.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<ol> <li>Getting Started</li> <li>Customization</li> <li>Credentials</li> <li>Reference</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"Credentials/","title":"Credentials","text":"<p>Getting Google API Credentials</p> <p>To use the Google Calendar API, you will need to obtain API credentials from the Google Cloud Console. Follow these steps to get the credentials:</p> <ol> <li>Go to the Google Cloud Console.</li> <li>Create a new project or select an existing project.</li> <li>Navigate to the \"APIs &amp; Services\" tab and click on \"Credentials\".</li> <li>Click on the \"Create credentials\" button and select \"OAuth client ID\".</li> <li>Select \"Desktop app\" as the application type.</li> <li>Enter a name for the client ID and click \"Create\".</li> <li>Download the client ID and client secret to your computer.</li> <li>Store the client ID and secret securely in your application's configuration file or environment variables.</li> <li>When you run your application, it will prompt you to authenticate with your Google account and grant access to the Google Calendar API.</li> <li>Note that depending on the Google Cloud Console dashboard, some of these steps may differ slightly, but the general process is the same. Once you have obtained the credentials, you will be able to use them to authenticate your application and access the Google Calendar API.</li> </ol>"},{"location":"Credentials/#after-you-have-obtained-the-credentialsjson","title":"After you have obtained the credentials.json","text":"<p>You can use it to authenticate your application and access the Google Calendar Analytics.</p> <p>Move <code>credentials.json</code> file to your project folder and write: <pre><code>from google_calendar_analytics.authentication.auth import CalendarAuth\ncreds = CalendarAuth(token_path=\"your_folder/token.json\",\ncredentials_path=\"your_folder/credentials.json\").get_credentials()\n</code></pre></p> <p>Congratulations! You have successfully obtained the credentials and can now use them to authenticate your application and access the Google Calendar Analytics.</p>"},{"location":"Customization/","title":"Customization","text":"<p>You can customize your plots by editing the <code>base_plot_design</code> object.</p> <pre><code>from google_calendar_analytics.authentication.auth import CalendarAuth\nfrom datetime import datetime\nfrom google_calendar_analytics.analytics import AnalyzerFacade\nfrom googleapiclient.discovery import build, Resource  # type: ignore\nfrom google_calendar_analytics.visualization.visual_design import base_plot_design\nimport asyncio\ncreds = CalendarAuth(\ntoken_path=\"./token.json\",\ncredentials_path=\"./credentials.json\",\n).get_credentials()\nstart_time = datetime(2023, 3, 1)\nend_time = datetime(2023, 3, 30)\nbase_plot_design.transparency = 0.8\nbase_plot_design.grid_width = 0.2\nbase_plot_design.grid_color = \"white\"\nbase_plot_design.line_shape = \"spline\"\nbase_plot_design.rgb_line_color = \"rgb(0, 255, 0)\"\nbase_plot_design.dark_theme = True\nbase_plot_design.show_title = False\nbase_plot_design.show_legend = False\nasync def main():\nasync with AnalyzerFacade(creds=creds) as analyzer:\ncoroutines = []\ncoroutines.append(analyzer.analyze_one(start_time, end_time, event_name=\"Programming\", plot_type=\"Line\", style_class=dark_plot_design))\nresult = await asyncio.gather(*coroutines)\nfor plot in result:\nplot.show()\nif __name__ == \"__main__\":\nasyncio.run(main())\n</code></pre> <p>Also, you can create many design objects and use them in your code.</p> <pre><code>from google_calendar_analytics.visualization.visual_design import VisualDesign\nsunny_design = VisualDesign(\ntransparency=0.5,\ngrid_width=0.1,\ngrid_color=\"white\",\nline_shape=\"spline\",\nrgb_line_color=\"rgb(0, 255, 0)\",\ndark_theme=False,\nshow_title=False,\nshow_legend=False,\n)\nrainy_design = VisualDesign(\ntransparency=0.5,\ngrid_width=0.1,\ngrid_color=\"white\",\nline_shape=\"spline\",\nrgb_line_color=\"rgb(0, 0, 255)\",\ndark_theme=True,\nshow_title=False,\nshow_legend=False,\n)\nasync def main():\nasync with AnalyzerFacade(creds=creds) as analyzer:\ncoroutines = []\ncoroutines.append(analyzer.analyze_one(start_time, end_time, event_name=\"Programming\", plot_type=\"Line\", style_class=sunny_design))\ncoroutines.append(analyzer.analyze_one(start_time, end_time, event_name=\"Programming\", plot_type=\"Line\", style_class=rainy_design))\nresult = await asyncio.gather(*coroutines)\nfor plot in result:\nplot.show()\n</code></pre>"},{"location":"Customization/#plot-design","title":"Plot design","text":"<p>Available plot design variables:</p> <p>A class that represents the visual design of the plots.</p> Source code in <code>google_calendar_analytics/visualization/visual_design.py</code> <pre><code>@dataclass\nclass VisualDesign:\n\"\"\"\n    A class that represents the visual design of the plots.\n    \"\"\"\ngrid_color: str = None  # type: ignore\nfont_color: str = None  # type: ignore\nrgb_colors: tuple = pastel_palette\nrgb_line_color: str = \"rgb(255, 0, 0)\"\nline_shape: str = \"linear\"\ngrid_width: float = 0.1\ntransparency: float = 1.0\nline_width: float = 2.0\nwidth: int = 800\nheight: int = 400\ndark_theme: bool = False\nshow_grid: bool = True\nshow_title: bool = True\nshow_legend: bool = True\nshow_xaxis_title: bool = True\nshow_yaxis_title: bool = True\ndef __post_init__(self):\n\"\"\"\n        Check if the line_shape parameter is a valid line shape.\n        \"\"\"\nvalid_shapes = (\"linear\", \"spline\", \"hv\", \"vh\", \"hvh\", \"vhv\")\nif self.line_shape not in valid_shapes:\nraise ValueError(\nf\"Invalid line_shape: {self.line_shape}. Valid options are: {valid_shapes}\"\n)\n</code></pre> <p>title: Plot design</p>"},{"location":"Customization/#google_calendar_analytics.visualization.visual_design.VisualDesign.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Check if the line_shape parameter is a valid line shape.</p> Source code in <code>google_calendar_analytics/visualization/visual_design.py</code> <pre><code>def __post_init__(self):\n\"\"\"\n    Check if the line_shape parameter is a valid line shape.\n    \"\"\"\nvalid_shapes = (\"linear\", \"spline\", \"hv\", \"vh\", \"hvh\", \"vhv\")\nif self.line_shape not in valid_shapes:\nraise ValueError(\nf\"Invalid line_shape: {self.line_shape}. Valid options are: {valid_shapes}\"\n)\n</code></pre>"},{"location":"Customization/#plot-types","title":"Plot types","text":"<p>You can choose from the following plot types:</p>"},{"location":"Customization/#bar","title":"Bar","text":""},{"location":"Customization/#line","title":"Line","text":""},{"location":"Customization/#multyline","title":"MultyLine","text":""},{"location":"Customization/#pie","title":"Pie","text":""},{"location":"Customization/#restrictions","title":"Restrictions","text":"<p>Note that not all plot types have the <code>max_events</code> variable available. If you want to limit the number of events to be analyzed, you should use the <code>Bar</code>, <code>Pie</code> plot type instead of <code>Line</code> or <code>MultyLine</code>.</p> <p>Also, you can't use <code>analyze_many</code> method with <code>Line</code> or <code>MultyLine</code> plot types because these plots are not suitable for multiple events.</p>"},{"location":"Getting-started/","title":"Getting started","text":"<p>To use the Google Calendar Analytics, first install the dependencies by running the following command:</p> <pre><code>pip install google-calendar-analytics\n</code></pre> <p>You can then import the AnalyzerFacade class and use it to analyze your data:</p>"},{"location":"Getting-started/#how-to-get-credentials-from-google","title":"How to get credentials from Google?","text":"<ol> <li>Google documentation</li> <li>Our documentation</li> </ol> <pre><code>import asyncio\nfrom datetime import datetime\nfrom google.oauth2.credentials import Credentials\nfrom google_calendar_analytics import AnalyzerFacade\n# (You can get it from Google OAuth2 in you web app or from link above)\n# Example of creds dictionary. (You can get it from Google OAuth2 in your web app)\ncreds = {\n\"token\": \"ya29.a0AVvZVsoH4qZcrGK25VwsXspJv-r9K-\",\n\"refresh_token\": \"1//0hwlhrtalKgeRCgYIARAAGBESNwF-\",\n\"token_uri\": \"https://oauth2.googleapis.com/token\",\n\"client_id\": \"395np.apps.googleusercontent.com\",\n\"client_secret\": \"GOCSPXFqoucE03VRVz\",\n\"scopes\": [\"https://www.googleapis.com/auth/calendar\"],\n\"expiry\": \"2023-02-18T15:30:15.674219Z\"\n}\ncreds = Credentials.from_authorized_user_info(creds)\n</code></pre> <p>Once you have created the credentials, you can create an instance of the AnalyzerFacade class and use it to analyze your data:</p> <pre><code>analyzer = AnalyzerFacade(creds=creds)\n# Choose time range for analysis\nstart_time = datetime(2023, 3, 1)\nend_time = datetime(2023, 3, 18)\nasync def main():\nasync with AnalyzerFacade(creds=creds) as analyzer:\nplot = await analyzer.analyze_one(start_time, end_time, event_name=\"Programming\", plot_type=\"Line\")\nplot.show()\nif __name__ == \"__main__\":\nasyncio.run(main())\n</code></pre> <p>What's about multiple plots? <pre><code>async def main():\nasync with AnalyzerFacade(creds=creds) as analyzer:\ncoroutines = []\ncoroutines.append(analyzer.analyze_one(start_time, end_time, event_name=\"Programming\", plot_type=\"Line\")\ncoroutines.append(analyzer.analyze_one(start_time, end_time, event_name=\"Reading\", plot_type=\"Line\"))\ncoroutines.append(analyzer.analyze_many(start_time, end_time, event_name=\"Programming\", plot_type=\"Pie\"))\nresult = await asyncio.gather(*coroutines)\nfor plot in result:\nplot.show()\n</code></pre></p>"},{"location":"References/","title":"References","text":""},{"location":"References/#google_calendar_analytics.analytics--analytics","title":"Analytics","text":"<p>The analytics module provides a facade class for analyzing calendar events and generating charts. The module uses a CalendarDataCollector to retrieve events from the Google Calendar API and a DataTransformer to transform the data into the format required by the plotting functions. The plotting is done by creating instances of PlotFactory.</p> <p>The AnalyzerFacade class provides three methods for analyzing events: <code>analyze_one</code>, <code>analyze_many</code>, and <code>analyze_one_with_periods</code>. The <code>analyze_one</code> method analyzes a single event, the analyze_many method analyzes multiple events, and the analyze_one_with_periods method analyzes a single event over a period of time.</p> <p>The AnalyzerBuilder class is a builder class that allows for creating instances of the AnalyzerFacade class with different options.</p>"},{"location":"References/#google_calendar_analytics.analytics.AnalyzerFacade","title":"<code>AnalyzerFacade</code>","text":"<p>Facade class for analyzing calendar events and generating charts.</p> <p>The class provides three methods for analyzing events: <code>analyze_one</code>, 'analyze_many', and 'analyze_one_with_periods'. It uses a CalendarDataCollector to retrieve events from Google Calendar API and a DataTransformer to transform the data into the format required by the plotting functions. The plotting is done by creating instances of PlotFactory.</p> <p>Parameters:</p> Name Type Description Default <code>creds</code> <code>Credentials</code> <p>Google credentials class instance.</p> required <p>Attributes:</p> Name Type Description <code>creds</code> <code>Credentials</code> <p>An instance of the Credentials class.</p> <code>plot_type</code> <code>str</code> <p>The type of chart to be generated.</p> <code>max_events</code> <code>int</code> <p>The maximum number of events to be analyzed.</p> <code>ascending</code> <code>bool</code> <p>If True, sort the events in ascending order of duration.</p> <code>data_collector</code> <code>AsyncCalendarDataCollector</code> <p>An instance of the CalendarDataCollector class.</p> <p>Examples:</p> <pre><code># Initialize AnalyzerFacade and analyze a single event\nanalyzer = AnalyzerBuilder().with_credentials(creds).build()\nstart_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\nend_time = datetime(2023, 3, 18, tzinfo=pytz.UTC)\nevent_name = \"Meeting\"\nplot = await analyzer.analyze_one(start_time, end_time, event_name)\n# Initialize AnalyzerFacade and analyze multiple events\nanalyzer = AnalyzerBuilder().with_credentials(creds).build()\nstart_time = datetime(2023, 3, 1, 0, 0, 0)\nend_time = datetime(2023, 3, 31, 23, 59, 59)\nfig = await analyzer.analyze_many(start_time=start_time, end_time=end_time)\nfig.show()\n# Initialize AnalyzerFacade and analyze a single event over a period of time\nanalyzer = AnalyzerBuilder().with_credentials(creds).build()\nstart_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\nend_time = datetime(2023, 3, 31, tzinfo=pytz.UTC)\nevent_name = \"Meeting\"\nperiod_days = 7\nnum_periods = 2\nplot = await analyzer.analyze_one_with_periods(\nstart_time=start_time,\nend_time=end_time,\nevent_name=event_name,\nperiod_days=period_days,\nnum_periods=num_periods,\n)\n</code></pre> Source code in <code>google_calendar_analytics/analytics.py</code> <pre><code>class AnalyzerFacade:\n\"\"\"\n    Facade class for analyzing calendar events and generating charts.\n    The class provides three methods for analyzing events:\n    `analyze_one`, 'analyze_many', and 'analyze_one_with_periods'.\n    It uses a CalendarDataCollector to retrieve events from Google Calendar API and a DataTransformer\n    to transform the data into the format required by the plotting functions. The plotting is done by\n    creating instances of PlotFactory.\n    Args:\n        creds (Credentials): Google credentials class instance.\n    Attributes:\n        creds (Credentials): An instance of the Credentials class.\n        plot_type (str): The type of chart to be generated.\n        max_events (int): The maximum number of events to be analyzed.\n        ascending (bool): If True, sort the events in ascending order of duration.\n        data_collector (AsyncCalendarDataCollector): An instance of the CalendarDataCollector class.\n    Examples:\n        ```python\n        # Initialize AnalyzerFacade and analyze a single event\n        analyzer = AnalyzerBuilder().with_credentials(creds).build()\n        start_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\n        end_time = datetime(2023, 3, 18, tzinfo=pytz.UTC)\n        event_name = \"Meeting\"\n        plot = await analyzer.analyze_one(start_time, end_time, event_name)\n        # Initialize AnalyzerFacade and analyze multiple events\n        analyzer = AnalyzerBuilder().with_credentials(creds).build()\n        start_time = datetime(2023, 3, 1, 0, 0, 0)\n        end_time = datetime(2023, 3, 31, 23, 59, 59)\n        fig = await analyzer.analyze_many(start_time=start_time, end_time=end_time)\n        fig.show()\n        # Initialize AnalyzerFacade and analyze a single event over a period of time\n        analyzer = AnalyzerBuilder().with_credentials(creds).build()\n        start_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\n        end_time = datetime(2023, 3, 31, tzinfo=pytz.UTC)\n        event_name = \"Meeting\"\n        period_days = 7\n        num_periods = 2\n        plot = await analyzer.analyze_one_with_periods(\n        start_time=start_time,\n        end_time=end_time,\n        event_name=event_name,\n        period_days=period_days,\n        num_periods=num_periods,\n        )\n        ```\n    \"\"\"\ndef __init__(self, creds: Credentials):\nself.style_class = None\nself.creds = creds\nself.plot_type = \"Line\"\nself.max_events = 5\nself.ascending = False\nself.session = None\nself.data_collector = None\nasync def __aenter__(self):\nssl_context = ssl.create_default_context(cafile=certifi.where())\nself.session = aiohttp.ClientSession(\nconnector=aiohttp.TCPConnector(ssl=ssl_context)\n)\nself.data_collector = AsyncCalendarDataCollector(self.creds, self.session)\nreturn self\nasync def __aexit__(self, exc_type, exc, tb):\nif self.session:\nawait self.session.close()\nself.session = None\nself.data_collector = None\nasync def analyze_one(\nself,\nstart_time: datetime,\nend_time: datetime,\nevent_name: str,\nplot_type: str,\nstyle_class: VisualDesign = base_plot_design,\n**kwargs\n) -&gt; go.Figure:\n\"\"\"\n        Analyze a single event and generate a plot.\n        This method analyzes a single event from the specified start time to end time and generates a plot using the OneEventDurationStrategy. The method uses a CalendarDataCollector to retrieve events from the Google Calendar API, a DataTransformer to transform the data into the required format, and a PlotFactory to generate the plot.\n        Args:\n            start_time (datetime): The start time for the analysis.\n            end_time (datetime): The end time for the analysis.\n            event_name (str): The name of the event to analyze.\n            plot_type (str): The type of plot to generate.\n            style_class (Type[VisualDesign]): The class that defines the style of the plot.\n            **kwargs: Additional keyword arguments for the plot creation.\n        Returns:\n            go.Figure: The plot generated by the PlotFactory.\n        Raises:\n            None\n        Examples:\n            To analyze a single event from March 1, 2023 to March 18, 2023 with the name \"Meeting\" and generate a plot, use:\n            ```\n            analyzer = AnalyzerBuilder().with_credentials(creds).build()\n            start_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\n            end_time = datetime(2023, 3, 18, tzinfo=pytz.UTC)\n            event_name = \"Meeting\"\n            plot = await analyzer.analyze_one(start_time, end_time, event_name)\n            ```\n        \"\"\"\nif plot_type not in (\"Line\",):\nraise exceptions.InvalidPlotTypeError(self.plot_type, method=\"analyze_one\")\nself.style_class = style_class\nself.plot_type = plot_type\nreturn await self._analyze(\nstart_time=start_time,\nend_time=end_time,\nevent_name=event_name,\nmethod=\"one\",\ntransformer_strategy=OneEventDurationStrategy(),\n)\nasync def analyze_many(\nself,\nstart_time: datetime,\nend_time: datetime,\nplot_type: str,\nmax_events: int = 5,\nascending=False,\nstyle_class: VisualDesign = base_plot_design,\n**kwargs\n) -&gt; go.Figure:\n\"\"\"\n        Analyze multiple calendar events and generate a plot of their durations.\n        Args:\n            start_time (datetime): The start time for the analysis.\n            end_time (datetime): The end time for the analysis.\n            plot_type (str): The type of plot to generate.\n            max_events (int): The maximum number of events to analyze.\n            ascending (bool): If True, sort the events in ascending order of duration.\n            style_class (Type[VisualDesign]): The class that defines the style of the plot.\n            **kwargs: Additional keyword arguments for the plot creation.\n        Returns:\n            go.Figure: The plot generated by the PlotFactory.\n        Raises:\n            None\n        Examples:\n            ```\n            analyzer = AnalyzerBuilder().with_credentials(creds).build()\n            start_time = datetime(2023, 3, 1, 0, 0, 0)\n            end_time = datetime(2023, 3, 31, 23, 59, 59)\n            fig = await analyzer.analyze_many(start_time=start_time, end_time=end_time)\n            fig.show()\n            ```\n        \"\"\"\nif plot_type not in (\"Bar\", \"Pie\"):\nraise exceptions.InvalidPlotTypeError(self.plot_type, method=\"analyze_many\")\nself.style_class = style_class\nself.plot_type = plot_type\nself.max_events = max_events\nself.ascending = ascending\nreturn await self._analyze(\nstart_time=start_time,\nend_time=end_time,\nmethod=\"many\",\ntransformer_strategy=ManyEventsDurationStrategy(),\n)\nasync def analyze_one_with_periods(\nself,\nstart_time: datetime,\nend_time: datetime,\nevent_name: str,\nplot_type: str,\nperiod_days: int = 7,\nnum_periods: int = 2,\nstyle_class: VisualDesign = base_plot_design,\n**kwargs\n) -&gt; go.Figure:\n\"\"\"\n        Analyze a single event over multiple periods of time and generate a plot.\n        This method analyzes a single event from the specified start time to end time over multiple periods of time using the EventDurationPeriodsStrategy. The method uses a CalendarDataCollector to retrieve events from the Google Calendar API, a DataTransformer to transform the data into the required format, and a PlotFactory to generate the plot.\n        Args:\n            start_time (datetime): The start time for the analysis.\n            end_time (datetime): The end time for the analysis.\n            event_name (str): The name of the event to analyze.\n            period_days (int, optional): The number of days in each period. Defaults to 7.\n            num_periods (int, optional): The number of periods to analyze. Defaults to 2.\n            plot_type (str): The type of plot to generate.\n            style_class (Type[VisualDesign]): The class that defines the style of the plot.\n            **kwargs: Additional keyword arguments for the plot creation.\n        Returns:\n            go.Figure: The plot generated by the PlotFactory.\n        Raises:\n            None\n        Examples:\n            To analyze a single event named \"Meeting\" from March 1, 2023 to March 31, 2023 over two periods of 7 days and generate a plot, use:\n            ```\n            analyzer = AnalyzerBuilder().with_credentials(creds).build()\n            start_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\n            end_time = datetime(2023, 3, 31, tzinfo=pytz.UTC)\n            event_name = \"Meeting\"\n            period_days = 7\n            num_periods = 2\n            plot = await analyzer.analyze_one_with_periods(start_time, end_time, event_name, period_days, num_periods)\n            ```\n        \"\"\"\nif plot_type not in (\"MultyLine\",):\nraise exceptions.InvalidPlotTypeError(\nself.plot_type, method=\"analyze_one_with_periods\"\n)\nself.style_class = style_class\nself.plot_type = plot_type\nreturn await self._analyze(\nstart_time=start_time,\nend_time=end_time,\nevent_name=event_name,\nmethod=\"one_with_periods\",\nperiod_days=period_days,\nnum_periods=num_periods,\ntransformer_strategy=EventDurationPeriodsStrategy(),\n)\nasync def _analyze(\nself,\nstart_time: datetime,\nend_time: datetime,\ntransformer_strategy: EventDurationStrategy,\nevent_name: str = None,  # type: ignore\nmethod: str = \"one\",\nperiod_days: int = 7,\nnum_periods: int = 2,\n**kwargs\n) -&gt; go.Figure:\n\"\"\"\n        Analyzes calendar events data and creates a plot using the specified method.\n        Args:\n            start_time (datetime): The start time for the analysis.\n            end_time (datetime): The end time for the analysis.\n            event_name (str, optional): The name of the event to analyze. Required for the 'one' and 'one_with_periods' methods. Defaults to None.\n            transformer_strategy (DataTransformerStrategy): The strategy to use for data transformation.\n            method (str, optional): The method to use for analysis. Must be one of 'one', 'many', or 'one_with_periods'. Defaults to 'one'.\n            period_days (int, optional): The number of days in each period. Required for the 'one_with_periods' method. Defaults to 7.\n            num_periods (int, optional): The number of periods to analyze. Required for the 'one_with_periods' method. Defaults to 2.\n            **kwargs: Additional keyword arguments for the plot creation.\n        Returns:\n            go.Figure: The plot generated by the PlotFactory.\n        Raises:\n            ValueError: If an invalid method is specified.\n        \"\"\"\nplot_creator = await PlotFactory(\nplot_type=self.plot_type,\nstyle_class=self.style_class,\n)\ncalendar_events = await self.data_collector.collect_data(\nstart_time=start_time,\nend_time=end_time,\n)\nif method == \"one\":\nevent_durations = await transformer_strategy.calculate_duration(\nevents=calendar_events, event_name=event_name\n)\nreturn await plot_creator.plot(\nevents=event_durations, event_name=event_name\n)\nelif method == \"many\":\nevent_durations = await transformer_strategy.calculate_duration(\nevents=calendar_events,\nmax_events=self.max_events,\nascending=self.ascending,\n)\nreturn await plot_creator.plot(events=event_durations)\nelif method == \"one_with_periods\":\nevent_durations = await transformer_strategy.calculate_duration(\nevents=calendar_events,\nevent_name=event_name,\nperiod_days=period_days,\nnum_periods=num_periods,\n)\nreturn await plot_creator.plot(\nevents=event_durations, event_name=event_name\n)\nelse:\nraise ValueError(\"Invalid method specified\")\n</code></pre>"},{"location":"References/#google_calendar_analytics.analytics.AnalyzerFacade.analyze_many","title":"<code>analyze_many(start_time, end_time, plot_type, max_events=5, ascending=False, style_class=base_plot_design, **kwargs)</code>  <code>async</code>","text":"<p>Analyze multiple calendar events and generate a plot of their durations.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>datetime</code> <p>The start time for the analysis.</p> required <code>end_time</code> <code>datetime</code> <p>The end time for the analysis.</p> required <code>plot_type</code> <code>str</code> <p>The type of plot to generate.</p> required <code>max_events</code> <code>int</code> <p>The maximum number of events to analyze.</p> <code>5</code> <code>ascending</code> <code>bool</code> <p>If True, sort the events in ascending order of duration.</p> <code>False</code> <code>style_class</code> <code>Type[VisualDesign]</code> <p>The class that defines the style of the plot.</p> <code>base_plot_design</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot creation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>go.Figure</code> <p>go.Figure: The plot generated by the PlotFactory.</p> <p>Examples:</p> <pre><code>analyzer = AnalyzerBuilder().with_credentials(creds).build()\nstart_time = datetime(2023, 3, 1, 0, 0, 0)\nend_time = datetime(2023, 3, 31, 23, 59, 59)\nfig = await analyzer.analyze_many(start_time=start_time, end_time=end_time)\nfig.show()\n</code></pre> Source code in <code>google_calendar_analytics/analytics.py</code> <pre><code>async def analyze_many(\nself,\nstart_time: datetime,\nend_time: datetime,\nplot_type: str,\nmax_events: int = 5,\nascending=False,\nstyle_class: VisualDesign = base_plot_design,\n**kwargs\n) -&gt; go.Figure:\n\"\"\"\n    Analyze multiple calendar events and generate a plot of their durations.\n    Args:\n        start_time (datetime): The start time for the analysis.\n        end_time (datetime): The end time for the analysis.\n        plot_type (str): The type of plot to generate.\n        max_events (int): The maximum number of events to analyze.\n        ascending (bool): If True, sort the events in ascending order of duration.\n        style_class (Type[VisualDesign]): The class that defines the style of the plot.\n        **kwargs: Additional keyword arguments for the plot creation.\n    Returns:\n        go.Figure: The plot generated by the PlotFactory.\n    Raises:\n        None\n    Examples:\n        ```\n        analyzer = AnalyzerBuilder().with_credentials(creds).build()\n        start_time = datetime(2023, 3, 1, 0, 0, 0)\n        end_time = datetime(2023, 3, 31, 23, 59, 59)\n        fig = await analyzer.analyze_many(start_time=start_time, end_time=end_time)\n        fig.show()\n        ```\n    \"\"\"\nif plot_type not in (\"Bar\", \"Pie\"):\nraise exceptions.InvalidPlotTypeError(self.plot_type, method=\"analyze_many\")\nself.style_class = style_class\nself.plot_type = plot_type\nself.max_events = max_events\nself.ascending = ascending\nreturn await self._analyze(\nstart_time=start_time,\nend_time=end_time,\nmethod=\"many\",\ntransformer_strategy=ManyEventsDurationStrategy(),\n)\n</code></pre>"},{"location":"References/#google_calendar_analytics.analytics.AnalyzerFacade.analyze_one","title":"<code>analyze_one(start_time, end_time, event_name, plot_type, style_class=base_plot_design, **kwargs)</code>  <code>async</code>","text":"<p>Analyze a single event and generate a plot.</p> <p>This method analyzes a single event from the specified start time to end time and generates a plot using the OneEventDurationStrategy. The method uses a CalendarDataCollector to retrieve events from the Google Calendar API, a DataTransformer to transform the data into the required format, and a PlotFactory to generate the plot.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>datetime</code> <p>The start time for the analysis.</p> required <code>end_time</code> <code>datetime</code> <p>The end time for the analysis.</p> required <code>event_name</code> <code>str</code> <p>The name of the event to analyze.</p> required <code>plot_type</code> <code>str</code> <p>The type of plot to generate.</p> required <code>style_class</code> <code>Type[VisualDesign]</code> <p>The class that defines the style of the plot.</p> <code>base_plot_design</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot creation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>go.Figure</code> <p>go.Figure: The plot generated by the PlotFactory.</p> <p>Examples:</p> <p>To analyze a single event from March 1, 2023 to March 18, 2023 with the name \"Meeting\" and generate a plot, use:</p> <pre><code>analyzer = AnalyzerBuilder().with_credentials(creds).build()\nstart_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\nend_time = datetime(2023, 3, 18, tzinfo=pytz.UTC)\nevent_name = \"Meeting\"\nplot = await analyzer.analyze_one(start_time, end_time, event_name)\n</code></pre> Source code in <code>google_calendar_analytics/analytics.py</code> <pre><code>async def analyze_one(\nself,\nstart_time: datetime,\nend_time: datetime,\nevent_name: str,\nplot_type: str,\nstyle_class: VisualDesign = base_plot_design,\n**kwargs\n) -&gt; go.Figure:\n\"\"\"\n    Analyze a single event and generate a plot.\n    This method analyzes a single event from the specified start time to end time and generates a plot using the OneEventDurationStrategy. The method uses a CalendarDataCollector to retrieve events from the Google Calendar API, a DataTransformer to transform the data into the required format, and a PlotFactory to generate the plot.\n    Args:\n        start_time (datetime): The start time for the analysis.\n        end_time (datetime): The end time for the analysis.\n        event_name (str): The name of the event to analyze.\n        plot_type (str): The type of plot to generate.\n        style_class (Type[VisualDesign]): The class that defines the style of the plot.\n        **kwargs: Additional keyword arguments for the plot creation.\n    Returns:\n        go.Figure: The plot generated by the PlotFactory.\n    Raises:\n        None\n    Examples:\n        To analyze a single event from March 1, 2023 to March 18, 2023 with the name \"Meeting\" and generate a plot, use:\n        ```\n        analyzer = AnalyzerBuilder().with_credentials(creds).build()\n        start_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\n        end_time = datetime(2023, 3, 18, tzinfo=pytz.UTC)\n        event_name = \"Meeting\"\n        plot = await analyzer.analyze_one(start_time, end_time, event_name)\n        ```\n    \"\"\"\nif plot_type not in (\"Line\",):\nraise exceptions.InvalidPlotTypeError(self.plot_type, method=\"analyze_one\")\nself.style_class = style_class\nself.plot_type = plot_type\nreturn await self._analyze(\nstart_time=start_time,\nend_time=end_time,\nevent_name=event_name,\nmethod=\"one\",\ntransformer_strategy=OneEventDurationStrategy(),\n)\n</code></pre>"},{"location":"References/#google_calendar_analytics.analytics.AnalyzerFacade.analyze_one_with_periods","title":"<code>analyze_one_with_periods(start_time, end_time, event_name, plot_type, period_days=7, num_periods=2, style_class=base_plot_design, **kwargs)</code>  <code>async</code>","text":"<p>Analyze a single event over multiple periods of time and generate a plot.</p> <p>This method analyzes a single event from the specified start time to end time over multiple periods of time using the EventDurationPeriodsStrategy. The method uses a CalendarDataCollector to retrieve events from the Google Calendar API, a DataTransformer to transform the data into the required format, and a PlotFactory to generate the plot.</p> <p>Parameters:</p> Name Type Description Default <code>start_time</code> <code>datetime</code> <p>The start time for the analysis.</p> required <code>end_time</code> <code>datetime</code> <p>The end time for the analysis.</p> required <code>event_name</code> <code>str</code> <p>The name of the event to analyze.</p> required <code>period_days</code> <code>int</code> <p>The number of days in each period. Defaults to 7.</p> <code>7</code> <code>num_periods</code> <code>int</code> <p>The number of periods to analyze. Defaults to 2.</p> <code>2</code> <code>plot_type</code> <code>str</code> <p>The type of plot to generate.</p> required <code>style_class</code> <code>Type[VisualDesign]</code> <p>The class that defines the style of the plot.</p> <code>base_plot_design</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot creation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>go.Figure</code> <p>go.Figure: The plot generated by the PlotFactory.</p> <p>Examples:</p> <p>To analyze a single event named \"Meeting\" from March 1, 2023 to March 31, 2023 over two periods of 7 days and generate a plot, use:</p> <pre><code>analyzer = AnalyzerBuilder().with_credentials(creds).build()\nstart_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\nend_time = datetime(2023, 3, 31, tzinfo=pytz.UTC)\nevent_name = \"Meeting\"\nperiod_days = 7\nnum_periods = 2\nplot = await analyzer.analyze_one_with_periods(start_time, end_time, event_name, period_days, num_periods)\n</code></pre> Source code in <code>google_calendar_analytics/analytics.py</code> <pre><code>async def analyze_one_with_periods(\nself,\nstart_time: datetime,\nend_time: datetime,\nevent_name: str,\nplot_type: str,\nperiod_days: int = 7,\nnum_periods: int = 2,\nstyle_class: VisualDesign = base_plot_design,\n**kwargs\n) -&gt; go.Figure:\n\"\"\"\n    Analyze a single event over multiple periods of time and generate a plot.\n    This method analyzes a single event from the specified start time to end time over multiple periods of time using the EventDurationPeriodsStrategy. The method uses a CalendarDataCollector to retrieve events from the Google Calendar API, a DataTransformer to transform the data into the required format, and a PlotFactory to generate the plot.\n    Args:\n        start_time (datetime): The start time for the analysis.\n        end_time (datetime): The end time for the analysis.\n        event_name (str): The name of the event to analyze.\n        period_days (int, optional): The number of days in each period. Defaults to 7.\n        num_periods (int, optional): The number of periods to analyze. Defaults to 2.\n        plot_type (str): The type of plot to generate.\n        style_class (Type[VisualDesign]): The class that defines the style of the plot.\n        **kwargs: Additional keyword arguments for the plot creation.\n    Returns:\n        go.Figure: The plot generated by the PlotFactory.\n    Raises:\n        None\n    Examples:\n        To analyze a single event named \"Meeting\" from March 1, 2023 to March 31, 2023 over two periods of 7 days and generate a plot, use:\n        ```\n        analyzer = AnalyzerBuilder().with_credentials(creds).build()\n        start_time = datetime(2023, 3, 1, tzinfo=pytz.UTC)\n        end_time = datetime(2023, 3, 31, tzinfo=pytz.UTC)\n        event_name = \"Meeting\"\n        period_days = 7\n        num_periods = 2\n        plot = await analyzer.analyze_one_with_periods(start_time, end_time, event_name, period_days, num_periods)\n        ```\n    \"\"\"\nif plot_type not in (\"MultyLine\",):\nraise exceptions.InvalidPlotTypeError(\nself.plot_type, method=\"analyze_one_with_periods\"\n)\nself.style_class = style_class\nself.plot_type = plot_type\nreturn await self._analyze(\nstart_time=start_time,\nend_time=end_time,\nevent_name=event_name,\nmethod=\"one_with_periods\",\nperiod_days=period_days,\nnum_periods=num_periods,\ntransformer_strategy=EventDurationPeriodsStrategy(),\n)\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory--visualizerfactory","title":"VisualizerFactory","text":"<p>This module provides classes for generating visualizations of event data using Pandas and Plotly libraries. It includes classes for bar charts, pie charts, and line charts of event durations, as well as multiple line charts for events over multiple periods. The Plot class defines some common properties for all visualization classes, while the ManyEventPlot and OneEventPlot classes define required abstract methods. The factory method PlotFactory returns an object of the specified visualization class based on input parameters.</p>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.BarPlot","title":"<code>BarPlot</code>","text":"<p>         Bases: <code>ManyEventPlot</code></p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>class BarPlot(ManyEventPlot):\nasync def plot(\nself,\nevents: pd.DataFrame,\ntitle: str = \"Top events with the Longest Duration\",\n**kwargs,\n) -&gt; go.Figure:\n\"\"\"\n        Plot a bar chart of the event durations.\n        Args:\n            events (pd.DataFrame): A DataFrame containing the event names as the index and the event durations as values.\n            title (str): The title of the chart.\n        \"\"\"\nfig = go.Figure(\ngo.Bar(\nx=events.Event,\ny=events.Duration,\nname=\"Duration\",\nmarker=dict(color=self.style_class.rgb_colors, colorscale=\"Blues\"),\n)\n)\nif self.style_class.show_xaxis_title:\nfig.update_xaxes(title_text=\"Event\")\nif self.style_class.show_yaxis_title:\nfig.update_yaxes(title_text=\"Duration (Hours)\")\nif self.style_class.show_title:\nfig.update_layout(\ntitle=title,\ntitle_font=dict(size=18, color=self.font_color),\n)\nfig.update_layout(\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\nfont=dict(color=self.font_color),\n)\nfig.update_traces(\nhovertemplate=\"&lt;b&gt;Event:&lt;/b&gt; %{x} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; %{y:.2f} hours\",\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.BarPlot.plot","title":"<code>plot(events, title='Top events with the Longest Duration', **kwargs)</code>  <code>async</code>","text":"<p>Plot a bar chart of the event durations.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>pd.DataFrame</code> <p>A DataFrame containing the event names as the index and the event durations as values.</p> required <code>title</code> <code>str</code> <p>The title of the chart.</p> <code>'Top events with the Longest Duration'</code> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>async def plot(\nself,\nevents: pd.DataFrame,\ntitle: str = \"Top events with the Longest Duration\",\n**kwargs,\n) -&gt; go.Figure:\n\"\"\"\n    Plot a bar chart of the event durations.\n    Args:\n        events (pd.DataFrame): A DataFrame containing the event names as the index and the event durations as values.\n        title (str): The title of the chart.\n    \"\"\"\nfig = go.Figure(\ngo.Bar(\nx=events.Event,\ny=events.Duration,\nname=\"Duration\",\nmarker=dict(color=self.style_class.rgb_colors, colorscale=\"Blues\"),\n)\n)\nif self.style_class.show_xaxis_title:\nfig.update_xaxes(title_text=\"Event\")\nif self.style_class.show_yaxis_title:\nfig.update_yaxes(title_text=\"Duration (Hours)\")\nif self.style_class.show_title:\nfig.update_layout(\ntitle=title,\ntitle_font=dict(size=18, color=self.font_color),\n)\nfig.update_layout(\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\nfont=dict(color=self.font_color),\n)\nfig.update_traces(\nhovertemplate=\"&lt;b&gt;Event:&lt;/b&gt; %{x} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; %{y:.2f} hours\",\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.LinePlot","title":"<code>LinePlot</code>","text":"<p>         Bases: <code>OneEventPlot</code></p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>class LinePlot(OneEventPlot):\nasync def plot(\nself,\nevents: pd.DataFrame,\nevent_name: str,\n**kwargs,\n) -&gt; go.Figure:\n\"\"\"\n        Plot a line chart of the event durations.\n        Args:\n            events (pd.DataFrame): A DataFrame containing the event dates as the index and the event durations as the values.\n            event_name (str): The name of the event.\n        \"\"\"\nfig = go.Figure()\nfig.add_trace(\ngo.Scatter(\nx=events.Date,\ny=events.Duration,\nmode=\"lines+markers\",\nline=dict(\ncolor=self.style_class.rgb_line_color,\nwidth=self.style_class.line_width,\nshape=self.style_class.line_shape,\n),\nmarker=dict(size=6, color=self.style_class.rgb_line_color),\nname=\"Duration\",\n)\n)\nif self.style_class.show_title:\nfig.update_layout(\ntitle=dict(\ntext=f\"Time spent on {event_name}\",\nfont=dict(size=16, color=self.font_color),\n)\n)\nif self.style_class.show_xaxis_title:\nfig.update_xaxes(title_text=\"Date\")\nif self.style_class.show_yaxis_title:\nfig.update_yaxes(title_text=\"Duration (hours)\")\nfig.update_layout(\nxaxis=dict(\nshowgrid=self.style_class.show_grid,\nnticks=10,\ndtick=\"D5\",\ngridcolor=self.grid_color,\ngridwidth=self.style_class.grid_width,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\ntickcolor=self.font_color,\n),\nyaxis=dict(\nshowgrid=self.style_class.show_grid,\ngridwidth=self.style_class.grid_width,\ngridcolor=self.grid_color,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\ntickcolor=self.font_color,\n),\nmargin=dict(l=50, r=50, t=80, b=50),\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\n)\nfig.update_traces(\nhovertemplate=\"&lt;b&gt;Date:&lt;/b&gt; %{x} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; %{y:.2f} hours\"\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.LinePlot.plot","title":"<code>plot(events, event_name, **kwargs)</code>  <code>async</code>","text":"<p>Plot a line chart of the event durations.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>pd.DataFrame</code> <p>A DataFrame containing the event dates as the index and the event durations as the values.</p> required <code>event_name</code> <code>str</code> <p>The name of the event.</p> required Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>async def plot(\nself,\nevents: pd.DataFrame,\nevent_name: str,\n**kwargs,\n) -&gt; go.Figure:\n\"\"\"\n    Plot a line chart of the event durations.\n    Args:\n        events (pd.DataFrame): A DataFrame containing the event dates as the index and the event durations as the values.\n        event_name (str): The name of the event.\n    \"\"\"\nfig = go.Figure()\nfig.add_trace(\ngo.Scatter(\nx=events.Date,\ny=events.Duration,\nmode=\"lines+markers\",\nline=dict(\ncolor=self.style_class.rgb_line_color,\nwidth=self.style_class.line_width,\nshape=self.style_class.line_shape,\n),\nmarker=dict(size=6, color=self.style_class.rgb_line_color),\nname=\"Duration\",\n)\n)\nif self.style_class.show_title:\nfig.update_layout(\ntitle=dict(\ntext=f\"Time spent on {event_name}\",\nfont=dict(size=16, color=self.font_color),\n)\n)\nif self.style_class.show_xaxis_title:\nfig.update_xaxes(title_text=\"Date\")\nif self.style_class.show_yaxis_title:\nfig.update_yaxes(title_text=\"Duration (hours)\")\nfig.update_layout(\nxaxis=dict(\nshowgrid=self.style_class.show_grid,\nnticks=10,\ndtick=\"D5\",\ngridcolor=self.grid_color,\ngridwidth=self.style_class.grid_width,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\ntickcolor=self.font_color,\n),\nyaxis=dict(\nshowgrid=self.style_class.show_grid,\ngridwidth=self.style_class.grid_width,\ngridcolor=self.grid_color,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\ntickcolor=self.font_color,\n),\nmargin=dict(l=50, r=50, t=80, b=50),\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\n)\nfig.update_traces(\nhovertemplate=\"&lt;b&gt;Date:&lt;/b&gt; %{x} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; %{y:.2f} hours\"\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.ManyEventPlot","title":"<code>ManyEventPlot</code>","text":"<p>         Bases: <code>Plot</code></p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>class ManyEventPlot(Plot):\ndef __init__(self, **kwargs):\nsuper().__init__(**kwargs)\n@abstractmethod\nasync def plot(\nself,\nevents: pd.DataFrame,\ntitle: str = \"Title\",\n):\n\"\"\"\n        Analyze one event for a certain period of time.\n        \"\"\"\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.ManyEventPlot.plot","title":"<code>plot(events, title='Title')</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Analyze one event for a certain period of time.</p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>@abstractmethod\nasync def plot(\nself,\nevents: pd.DataFrame,\ntitle: str = \"Title\",\n):\n\"\"\"\n    Analyze one event for a certain period of time.\n    \"\"\"\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.MultyLinePlot","title":"<code>MultyLinePlot</code>","text":"<p>         Bases: <code>OneEventPlot</code></p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>class MultyLinePlot(OneEventPlot):\nasync def plot(self, events: pd.DataFrame, event_name: str, **kwargs) -&gt; go.Figure:\n\"\"\"\n        Plot a line chart of the event durations.\n        Args:\n            events (pd.DataFrame): A DataFrame containing the event dates as the index and the event durations as the values.\n            event_name (str): The name of the event.\n        \"\"\"\nfig = go.Figure()\n# Create a separate line for each period\nfor period in events.Period.unique():\nperiod_events = events[events.Period == period]\nperiod_start = period_events.Date.min().strftime(\"%m-%d\")\nperiod_end = period_events.Date.max().strftime(\"%m-%d\")\nperiod_label = f\"{period_start} to {period_end}\"\nfig.add_trace(\ngo.Scatter(\nx=period_events.Day,\ny=period_events.Duration,\nmode=\"lines+markers\",\nline=dict(width=2),\nmarker=dict(size=6),\nname=period_label,\ntext=period_events.Date,\nhovertemplate=\"&lt;b&gt;Date:&lt;/b&gt; %{text} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; %{y:.2f} hours\",\nshowlegend=self.style_class.show_legend,\n)\n)\nfig.update_layout(hovermode=\"x\")\nif self.style_class.show_title:\nfig.update_layout(\ntitle=dict(\ntext=f\"Time spent on {event_name}\",\nfont=dict(size=16, color=self.font_color),\n)\n)\nif self.style_class.show_xaxis_title:\nfig.update_xaxes(title_text=\"Day\")\nif self.style_class.show_yaxis_title:\nfig.update_yaxes(title_text=\"Duration (hours)\")\n# Update the color scheme and set the title of the figure\nfig.update_layout(\nxaxis=dict(\nshowgrid=self.style_class.show_grid,\ngridwidth=self.style_class.grid_width,\ndtick=\"D5\",\ngridcolor=self.grid_color,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\ntickcolor=self.font_color,\n),\nyaxis=dict(\nshowgrid=self.style_class.show_grid,\ngridwidth=self.style_class.grid_width,\ngridcolor=self.grid_color,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\n),\nmargin=dict(l=50, r=50, t=80, b=50),\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.MultyLinePlot.plot","title":"<code>plot(events, event_name, **kwargs)</code>  <code>async</code>","text":"<p>Plot a line chart of the event durations.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>pd.DataFrame</code> <p>A DataFrame containing the event dates as the index and the event durations as the values.</p> required <code>event_name</code> <code>str</code> <p>The name of the event.</p> required Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>async def plot(self, events: pd.DataFrame, event_name: str, **kwargs) -&gt; go.Figure:\n\"\"\"\n    Plot a line chart of the event durations.\n    Args:\n        events (pd.DataFrame): A DataFrame containing the event dates as the index and the event durations as the values.\n        event_name (str): The name of the event.\n    \"\"\"\nfig = go.Figure()\n# Create a separate line for each period\nfor period in events.Period.unique():\nperiod_events = events[events.Period == period]\nperiod_start = period_events.Date.min().strftime(\"%m-%d\")\nperiod_end = period_events.Date.max().strftime(\"%m-%d\")\nperiod_label = f\"{period_start} to {period_end}\"\nfig.add_trace(\ngo.Scatter(\nx=period_events.Day,\ny=period_events.Duration,\nmode=\"lines+markers\",\nline=dict(width=2),\nmarker=dict(size=6),\nname=period_label,\ntext=period_events.Date,\nhovertemplate=\"&lt;b&gt;Date:&lt;/b&gt; %{text} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; %{y:.2f} hours\",\nshowlegend=self.style_class.show_legend,\n)\n)\nfig.update_layout(hovermode=\"x\")\nif self.style_class.show_title:\nfig.update_layout(\ntitle=dict(\ntext=f\"Time spent on {event_name}\",\nfont=dict(size=16, color=self.font_color),\n)\n)\nif self.style_class.show_xaxis_title:\nfig.update_xaxes(title_text=\"Day\")\nif self.style_class.show_yaxis_title:\nfig.update_yaxes(title_text=\"Duration (hours)\")\n# Update the color scheme and set the title of the figure\nfig.update_layout(\nxaxis=dict(\nshowgrid=self.style_class.show_grid,\ngridwidth=self.style_class.grid_width,\ndtick=\"D5\",\ngridcolor=self.grid_color,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\ntickcolor=self.font_color,\n),\nyaxis=dict(\nshowgrid=self.style_class.show_grid,\ngridwidth=self.style_class.grid_width,\ngridcolor=self.grid_color,\ntitlefont=dict(size=14, color=self.font_color),\ntickfont=dict(size=12, color=self.font_color),\n),\nmargin=dict(l=50, r=50, t=80, b=50),\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.OneEventPlot","title":"<code>OneEventPlot</code>","text":"<p>         Bases: <code>Plot</code></p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>class OneEventPlot(Plot):\ndef __init__(self, **kwargs):\nsuper().__init__(**kwargs)\n@abstractmethod\nasync def plot(\nself,\nevents: pd.DataFrame,\nevent_name: str,\n):\n\"\"\"\n        Analyze one event for a certain period of time.\n        \"\"\"\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.OneEventPlot.plot","title":"<code>plot(events, event_name)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Analyze one event for a certain period of time.</p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>@abstractmethod\nasync def plot(\nself,\nevents: pd.DataFrame,\nevent_name: str,\n):\n\"\"\"\n    Analyze one event for a certain period of time.\n    \"\"\"\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.PiePlot","title":"<code>PiePlot</code>","text":"<p>         Bases: <code>ManyEventPlot</code></p> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>class PiePlot(ManyEventPlot):\nasync def plot(\nself,\nevents: pd.DataFrame,\ntitle: str = \"Top events with the Longest Duration\",\n**kwargs,\n) -&gt; go.Figure:\n\"\"\"\n        Plot a pie chart of the event durations.\n        Args:\n            events (pd.DataFrame): A DataFrame containing the event names as the index and the event durations as the values.\n            title (str): The title of the chart.\n        \"\"\"\nfig = go.Figure(\ngo.Pie(\nlabels=events.Event,\nvalues=events.Duration,\ntextposition=\"auto\",\nname=\"Duration\",\nmarker=dict(colors=self.style_class.rgb_colors),\ntextinfo=\"label+percent\",\nshowlegend=self.style_class.show_legend,\n)\n)\nif self.style_class.show_title:\nfig.update_layout(\ntitle=title,\ntitle_font=dict(size=18, color=self.font_color),\n)\nfig.update_layout(\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\nfont=dict(color=self.font_color),\n)\nfig.update_traces(\nhovertemplate=\"&lt;b&gt;Event:&lt;/b&gt; %{label} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; \\\n                           %{value:.2f} hours&lt;br&gt;&lt;b&gt;Percentage:&lt;/b&gt; %{percent}\",\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.PiePlot.plot","title":"<code>plot(events, title='Top events with the Longest Duration', **kwargs)</code>  <code>async</code>","text":"<p>Plot a pie chart of the event durations.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>pd.DataFrame</code> <p>A DataFrame containing the event names as the index and the event durations as the values.</p> required <code>title</code> <code>str</code> <p>The title of the chart.</p> <code>'Top events with the Longest Duration'</code> Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>async def plot(\nself,\nevents: pd.DataFrame,\ntitle: str = \"Top events with the Longest Duration\",\n**kwargs,\n) -&gt; go.Figure:\n\"\"\"\n    Plot a pie chart of the event durations.\n    Args:\n        events (pd.DataFrame): A DataFrame containing the event names as the index and the event durations as the values.\n        title (str): The title of the chart.\n    \"\"\"\nfig = go.Figure(\ngo.Pie(\nlabels=events.Event,\nvalues=events.Duration,\ntextposition=\"auto\",\nname=\"Duration\",\nmarker=dict(colors=self.style_class.rgb_colors),\ntextinfo=\"label+percent\",\nshowlegend=self.style_class.show_legend,\n)\n)\nif self.style_class.show_title:\nfig.update_layout(\ntitle=title,\ntitle_font=dict(size=18, color=self.font_color),\n)\nfig.update_layout(\nwidth=self.style_class.width,\nheight=self.style_class.height,\nplot_bgcolor=self.plot_bgcolor,\npaper_bgcolor=self.paper_bgcolor,\nfont=dict(color=self.font_color),\n)\nfig.update_traces(\nhovertemplate=\"&lt;b&gt;Event:&lt;/b&gt; %{label} &lt;br&gt;&lt;b&gt;Duration:&lt;/b&gt; \\\n                       %{value:.2f} hours&lt;br&gt;&lt;b&gt;Percentage:&lt;/b&gt; %{percent}\",\n)\nreturn fig\n</code></pre>"},{"location":"References/#google_calendar_analytics.visualization.visualizer_factory.PlotFactory","title":"<code>PlotFactory(style_class, plot_type='Pie', event_name='Event')</code>  <code>async</code>","text":"<p>Factory method to create a plot object.</p> <p>Parameters:</p> Name Type Description Default <code>plot_type</code> <code>str</code> <p>The type of plot to create.</p> <code>'Pie'</code> <code>event_name</code> <code>str</code> <p>The name of the event.</p> <code>'Event'</code> <code>style_class</code> <code>Type[base_plot_design]</code> <p>The style class to use for the plot.</p> required Source code in <code>google_calendar_analytics/visualization/visualizer_factory.py</code> <pre><code>async def PlotFactory(\nstyle_class: Type[base_plot_design], plot_type=\"Pie\", event_name=\"Event\"\n) -&gt; Plot:\n\"\"\"\n    Factory method to create a plot object.\n    Args:\n        plot_type (str): The type of plot to create.\n        event_name (str): The name of the event.\n        style_class (Type[base_plot_design]): The style class to use for the plot.\n    \"\"\"\nplots = {\n\"Pie\": PiePlot,\n\"Bar\": BarPlot,\n\"Line\": LinePlot,\n\"MultyLine\": MultyLinePlot,\n}\nif plot_type not in plots:\nraise ValueError(\nf\"Invalid plot type: '{plot_type}'.\\n\"\nf\"Available options are: {', '.join(plots.keys())}.\"\n)\nreturn plots[plot_type](style_class=style_class, event_name=event_name)\n</code></pre>"}]}